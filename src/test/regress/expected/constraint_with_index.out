-- Tests for 'constraints with existing index' feature
CREATE TABLE cwi_test( a int , b varchar(10), c char);
-- add some data so that all tests have something to work with.
INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
		USING INDEX cwi_uniq2_idx;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
DROP INDEX cwi_uniq2_idx;	-- Should fail; index doesn't exist
ERROR:  index "cwi_uniq2_idx" does not exist
CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(a , b);
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq2_idx;
-- Should fail; index doesn't exist
ALTER TABLE cwi_test ADD PRIMARY KEY
	USING INDEX cwi_idx_doesnt_exist;
ERROR:  index "cwi_idx_doesnt_exist" not found
ALTER TABLE cwi_test ADD UNIQUE (a);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "cwi_test_a_key" for table "cwi_test"
-- Should fail; already attached to a constraint
ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_test_a_key;
ERROR:  index "cwi_test_a_key" is associated with a constraint
CREATE INDEX cwi_idx1 ON cwi_test(a , b);
-- Should fail; non-unique
ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_idx1;
ERROR:  "cwi_idx1" is not a unique index
DETAIL:  Cannot create PRIMARY KEY/UNIQUE constraint using a non-unique index.
CREATE UNIQUE INDEX cwi_idx2 ON cwi_test(a , b);
-- Should fail; PKey already exists
ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_idx2;
ERROR:  multiple primary keys for table "cwi_test" are not allowed
ALTER TABLE cwi_test DROP CONSTRAINT cwi_replaced_pkey;
ALTER TABLE cwi_test ADD primary key(a, b);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "cwi_test_pkey" for table "cwi_test"
CREATE UNIQUE INDEX cwi_idx3 ON cwi_test(a);
ALTER TABLE cwi_test DROP CONSTRAINT cwi_test_pkey, ADD PRIMARY KEY
	USING INDEX cwi_idx3;
-- Should fail; primary key now depends on it
DROP INDEX cwi_idx3;
ERROR:  cannot drop index cwi_idx3 because constraint cwi_idx3 on table cwi_test requires it
HINT:  You can drop constraint cwi_idx3 on table cwi_test instead.
CREATE UNIQUE INDEX cwi_part_idx ON cwi_test( a ) WHERE c = 'c';
CREATE UNIQUE INDEX cwi_expr_idx ON cwi_test( (b || 'c') );
-- Should fail; partial index not allowed
ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_part_idx;
ERROR:  "cwi_part_idx" is a partial index
DETAIL:  Cannot create PRIMARY KEY/UNIQUE constraint using a partial index.
-- Should fail; expressional index not allowed
ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_expr_idx;
ERROR:  index "cwi_expr_idx" contains expressions
DETAIL:  Cannot create PRIMARY KEY/UNIQUE constraint using an expressional index.
SELECT relname, relkind FROM pg_class WHERE relname like E'cwi\\_%'
	ORDER BY relkind DESC, relname ASC;
    relname     | relkind 
----------------+---------
 cwi_test       | r
 cwi_expr_idx   | i
 cwi_idx1       | i
 cwi_idx2       | i
 cwi_idx3       | i
 cwi_part_idx   | i
 cwi_test_a_key | i
 cwi_uniq2_idx  | i
(8 rows)

DROP TABLE cwi_test;
SELECT relname, relkind FROM pg_class WHERE relname like E'cwi\\_%';
 relname | relkind 
---------+---------
(0 rows)

